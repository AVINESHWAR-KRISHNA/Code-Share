import java.util.concurrent.{Executors, TimeUnit}
import scala.concurrent.{ExecutionContext, Future, blocking}
import scala.concurrent.duration._
import scala.util.{Failure, Success, Try}

val notebookContext = dbutils.notebook.getContext()
val numberOfThreads = 5
val threadPool = Executors.newFixedThreadPool(numberOfThreads)
implicit val executionContext: ExecutionContext = ExecutionContext.fromExecutor(threadPool)

val parametersList: List[Map[String, String]] = List(
  arguments, arguments, arguments, arguments, arguments
)

def runNotebook(params: Map[String, String]): Future[String] = Future {
  dbutils.notebook.setContext(notebookContext)
  Try {
    dbutils.notebook.run("./ODS_Ingestion/Level_0_1", 60, params)
  } match {
    case Success(result) => result
    case Failure(ex) =>
      println(s"An error occurred: ${ex.getMessage}")
      "Error"
  }
}

def runWithRetry(params: Map[String, String], retries: Int = 3): Future[String] = {
  runNotebook(params).recoverWith {
    case _ if retries > 0 =>
      println(s"Retrying... attempts remaining: $retries")
      runWithRetry(params, retries - 1)
  }
}

val futures: List[Future[String]] = parametersList.map { params =>
  runWithRetry(params)
}

val allResults: Future[List[String]] = Future.sequence(futures)

allResults.onComplete {
  case Success(results) =>
    println("All tasks completed successfully")
    results.foreach(println)
  case Failure(ex) =>
    println(s"One or more tasks failed with error: ${ex.getMessage}")
}

try {
  blocking {
    Await.result(allResults, Duration.Inf)
  }
} finally {
  threadPool.shutdown()
  if (!threadPool.awaitTermination(1, TimeUnit.MINUTES)) {
    threadPool.shutdownNow()
  }
}