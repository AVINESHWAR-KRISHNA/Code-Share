import scala.concurrent._
import scala.concurrent.duration._
import scala.util.{Failure, Success}
import java.util.concurrent.Executors
import org.json4s._
import org.json4s.jackson.JsonMethods._
import org.json4s.jackson.Serialization.read

// Define the number of threads to use
val numberOfThreads = 10

// Create a fixed thread pool
val threadPool = Executors.newFixedThreadPool(numberOfThreads)

// Implicit execution context from the thread pool
implicit val executionContext: ExecutionContext = ExecutionContext.fromExecutor(threadPool)

// Define the task function to run a notebook
def task(arguments: Map[String, String]): Future[Unit] = Future {
  try {
    println("Running task")
    
    // Run the notebook synchronously
    val res = dbutils.notebook.run("/ODS_Ingestion/Level_0.1", 60, arguments)
    println(s"Notebook result: $res")
    
    // Parse the result into a JSON object
    val json = parse(res)
    val extractedMap = json.extract[Map[String, String]]
    
    // Print the extracted key-value pairs
    extractedMap.foreach { case (key, value) =>
      println(s"Key: $key, Value: $value")
    }
  } catch {
    case e: Exception => println(s"An error occurred: ${e.getMessage}")
  }
}

// List of arguments to be passed to the notebooks
val argumentsList = List(
  Map("param1" -> "value1"),
  Map("param1" -> "value2"),
  Map("param1" -> "value3"),
  Map("param1" -> "value4")
)

// Create a list of tasks
val tasks = argumentsList.map(task)

// Combine the futures into a single future and wait for all to complete
val resultFuture: Future[List[Unit]] = Future.sequence(tasks)

// Handling the results or errors
resultFuture.onComplete {
  case Success(_) => println("All tasks completed successfully")
  case Failure(ex) => println(s"One or more tasks failed with error: ${ex.getMessage}")
}

// Await the results to ensure all tasks complete
Await.result(resultFuture, Duration.Inf)

// Properly shutdown the thread pool
threadPool.shutdown()